#pragma once

#include <numeric>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "data.h"
#include "data_type.h"
#include "op_type.h"

/// @brief A tensor represented by which `node` it is passed to
/// and at which `slot` in inputs of that `node`.
struct InletPos {
    size_t node, slot;
};

/// @brief A tensor represented by which `node` it is generated from
/// and at which `slot` in outputs of that `node`.
struct OutletPos {
    size_t node, slot;
};

/// @brief Calculates the hash of `OutletPos`.
struct OutletPosHash {
    size_t operator()(OutletPos const &o) const {
        return o.node ^ (o.slot << 1);
    }
};

/// @brief The data structure represents a `Outlet` of a operator,
/// which generates a tensor, and it is part of the `Node`.
/// @tparam Tensor discripter.
template <class Tensor> struct Outlet {
    Tensor info;
    std::vector<InletPos> targets;

    explicit Outlet(Tensor info) : info(info), targets({}) {}
};

/// @brief The specific tensor information excludes all unknowns.
/// This struct can be used as a tensor discripter type in templates.
struct TensorInfo {
    std::vector<size_t> shape;
    DataType data_type;

    /// @brief Tensor memory usage.
    /// @return Memory bytes.
    size_t size() const {
        return shape.empty() // fmt: new line
                   ? 0
                   : std::accumulate(
                         shape.begin(), shape.end(), data_type.size(),
                         [](auto acc, auto it) { return acc * it; });
    }
};

/// @brief Operator `Node` of the dataflow `Graph`.
/// @tparam Tensor discripter.
template <class Tensor> struct Node {
    OpType op_type;
    std::vector<OutletPos> inputs;
    std::vector<Outlet<Tensor>> outputs;
};

/// @brief A reference of an operator `Node` in a dataflow `Graph`.
struct OpRef {
    /// @brief Index of operator `Node` in the corresponding `Graph`.
    size_t node_idx;

    /// @brief Builds `OutletPos` from `OpRef`.
    /// @param slot Index of output for operator `Node`.
    /// @return An `OutletPos`.
    OutletPos operator[](size_t slot) const { return {node_idx, slot}; }
};

/// @brief The dataflow `Graph`.
/// @tparam Tensor discripter.
///
/// **NOTICE** Methods of a template class must be defined in the same file
/// as the class.
template <class Tensor> class Graph {
    /// @brief `operators` must be topo sorted.
    std::vector<Node<Tensor>> _operators;

    /// @brief A map to store data, where the key is the index of input node,
    /// and the value is data.
    std::unordered_map<size_t, Data> _data;

    /// @brief
    std::unordered_map<size_t, size_t> _io_id;

    static size_t IO_ID;

  public:
    /// @brief Pushs a new operator `Node` into `Graph`.
    /// @param op_type Operator type.
    /// @param inputs Tensors passed to operator.
    /// @param outputs Tensors generated by operator.
    /// @return A reference to the `Node` in `Graph`.
    OpRef push_operator(                    // fmt: new line
        OpType op_type,                     //
        std::vector<OutletPos> inputs,      //
        std::vector<Outlet<Tensor>> outputs //
    ) {
        if (op_type == OpType::Input)
            throw "use `push_input` instead";
        else if (op_type == OpType::Output)
            throw "use `push_output` instead";

        auto index = _operators.size();

        for (const auto &input : inputs)
            if (input.node >= index)
                throw "input node not exist";

        size_t i = 0;
        for (const auto &input : inputs)
            _operators[input.node]   // fmt: new line
                .outputs[input.slot] //
                .targets             //
                .push_back({index, ++i});

        _operators.push_back({op_type, std::move(inputs), std::move(outputs)});
        return {index};
    }

    /// @brief Pushs a new `Input` `Node` into `Graph`.
    /// @param output Tensor from `Input`.
    /// @param id IO id of `Input`.
    /// @return A reference to the `Node` in `Graph`.
    OpRef push_input(Outlet<Tensor> output, std::optional<size_t> id) {
        auto index = _operators.size();
        _io_id[index] = id ? *id : IO_ID++;
        _operators.push_back({OpType::Input, {}, {output}});
        return {index};
    }

    /// @brief Pushs a new `Output` `Node` into `Graph`.
    /// @param input Tensor to `Output`.
    /// @param id IO id of `Output`.
    /// @return A reference to the `Node` in `Graph`.
    OpRef push_output(OutletPos input, std::optional<size_t> id) {
        auto index = _operators.size();
        _io_id[index] = id ? *id : IO_ID++;
        _operators.push_back({OpType::Output, {input}, {}});
        return {index};
    }

    /// @brief Pushs data of `Input` `Node` into `Graph`.
    /// @param input A reference to the `Input` `Node`.
    /// @param data Data to store.
    void push_data(OpRef const &input, Data data) {
        if (input.node_idx >= _operators.size())
            throw "input node not exist";
        const auto &op = _operators.at(input.node_idx);
        if (op.op_type != OpType::Input)
            throw "only input node can have data";
        if (!data.cpu_data.empty() &&
            data.cpu_data.size() != op.outputs.front().info.size())
            throw "wrong data size";
        _data[input.node_idx] = std::move(data);
    }

    /// @brief Gets operators in the `Graph`.
    /// @return Operators in the `Graph`.
    std::vector<Node<Tensor>> const &operators() const { return _operators; }

    /// @brief `Graph` inputs.
    /// @return Indices of input `Node`s in `Graph`.
    std::vector<size_t> inputs() const {
        std::vector<size_t> ans;
        size_t i = 0;
        for (const auto &node : _operators) {
            if (node.op_type == OpType::Input && _data.find(i) != _data.end())
                ans.push_back(i);
            ++i;
        }
        return ans;
    }

    /// @brief `Graph` outputs.
    /// @return Indices of output `Node`s in `Graph`.
    std::vector<size_t> outputs() const {
        std::vector<size_t> ans;
        size_t i = 0;
        for (const auto &node : _operators) {
            if (node.op_type == OpType::Output)
                ans.push_back(i);
            ++i;
        }
        return ans;
    }
};

template <class Tensor> size_t Graph<Tensor>::IO_ID = 0;
