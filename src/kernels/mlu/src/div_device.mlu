#include "div.h"

#define NRAM_USE_SIZE 102400

__nram__ char left[NRAM_USE_SIZE];
__nram__ char right[NRAM_USE_SIZE];
__nram__ char output[NRAM_USE_SIZE];

template<typename T>
__mlu_device__ void DivFunction(T* output1, T* input1, T* input2, size_t num) {
  int use_nram_size = NRAM_USE_SIZE;
  int deal_align = use_nram_size / sizeof(T);
  int num_per_core = num / taskDim;
  int num_rem = num % taskDim;
  int easy = num_per_core;
  int hard = num_per_core + (num_rem != 0 ? 1 : 0);
  int my = taskId < num_rem ? hard : easy;
  int start = (taskId < num_rem) ? (hard * taskId) : (hard * num_rem + (taskId - num_rem) * easy);
  char* input1_start = (char*)input1 + start * sizeof(T);
  char* input2_start = (char*)input2 + start * sizeof(T);
  char* output_start = (char*)output1 + start * sizeof(T);

  int my_repeat = my / deal_align;
  int my_rem = my % deal_align;
  for(int i = 0; i < my_repeat; ++i) {
    __memcpy(left, input1_start, use_nram_size, GDRAM2NRAM);
    __memcpy(right, input2_start, use_nram_size, GDRAM2NRAM);
    __bang_active_recip((T*)right, (T*)right, deal_align);
    __bang_mul((T*)output, (T*)left, (T*)right, deal_align);
    __memcpy(output_start, output, use_nram_size, NRAM2GDRAM);
    input1_start += use_nram_size;
    input2_start += use_nram_size;
    output_start += use_nram_size;
  }
  if(my_rem) {
    __memcpy(left, input1_start, my_rem * sizeof(T), GDRAM2NRAM);
    __memcpy(right, input2_start, my_rem * sizeof(T), GDRAM2NRAM);
    __bang_active_recip((T*)right, (T*)right, deal_align);
    __bang_mul((T*)output, (T*)left, (T*)right, deal_align);
    __memcpy(output_start, output, my_rem * sizeof(T), NRAM2GDRAM);
  }
}

__mlu_global__ void MLUDivKernelUnion1(float *output,
                                       float *input1,
                                       float *input2,
                                       uint32_t num) {
  DivFunction((float*)output, (float*)input1, (float*)input2, num);
}

