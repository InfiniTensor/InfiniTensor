#include "div.h"

#define NRAM_USE_SIZE 102400

__nram__ char left[NRAM_USE_SIZE];
__nram__ char right[NRAM_USE_SIZE];
__nram__ char output[NRAM_USE_SIZE];

template<typename T>
__mlu_device__ void DivFunction(T* output1, T* input1, T* input2, size_t num) {
    int use_nram_size = NRAM_USE_SIZE;
    int deal_align = use_nram_size / sizeof(T);
    int num_per_core = num / taskDim;
    int num_rem = num % taskDim;
    int easy = num_per_core;
    int hard = num_per_core + (num_rem != 0 ? 1 : 0);
    int my = taskId < num_rem ? hard : easy;
    int start = (taskId < num_rem) ? (hard * taskId) : (hard * num_rem + (taskId - num_rem) * easy);
    char* input1_start = (char*)input1 + start * sizeof(T);
    char* input2_start = (char*)input2 + start * sizeof(T);
    char* output_start = (char*)output1 + start * sizeof(T);

    int my_repeat = my / deal_align;
    int my_rem = my % deal_align;
    for(int i = 0; i < my_repeat; ++i) {
        __memcpy(left, input1_start, use_nram_size, GDRAM2NRAM);
        __memcpy(right, input2_start, use_nram_size, GDRAM2NRAM);
        __bang_active_recip((T*)right, (T*)right, deal_align);
        __bang_mul((T*)output, (T*)left, (T*)right, deal_align);
        __memcpy(output_start, output, use_nram_size, NRAM2GDRAM);
        input1_start += use_nram_size;
        input2_start += use_nram_size;
        output_start += use_nram_size;
    }
    if(my_rem) {
        __memcpy(left, input1_start, my_rem * sizeof(T), GDRAM2NRAM);
        __memcpy(right, input2_start, my_rem * sizeof(T), GDRAM2NRAM);
        __bang_active_recip((T*)right, (T*)right, deal_align);
        __bang_mul((T*)output, (T*)left, (T*)right, deal_align);
        __memcpy(output_start, output, my_rem * sizeof(T), NRAM2GDRAM);
    }
}

__mlu_global__ void MLUDivKernelUnion1(float *output,
                                       float *input1,
                                       float *input2,
                                       uint32_t num) {
    DivFunction((float*)output, (float*)input1, (float*)input2, num);
}

