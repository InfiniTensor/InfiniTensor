#include "acl/acl.h"
#include <stdio.h>
#include <stdlib.h>
#include "/home/zhangyunze/workplace/InfiniTensor/include/ascend/ascend_plugin_sub_kernel.h"

#ifdef ASCENDC_CPU_DEBUG
#define __aicore__
#else
#define __aicore__ [aicore]
#endif


constexpr int32_t BLOCK_NUM = 8; 
constexpr int32_t BUFFER_NUM = 4;
constexpr int32_t TILE_NUM = 62;
constexpr int32_t TILE_LENGTH_X = 5 * 1028;
constexpr int32_t TILE_LENGTH_Y = 1024;

#include "kernel_operator.h"
__global__ __aicore__ void PluginSub(__gm__ float* x, __gm__ float* y, __gm__ float* output, size_t inputByteSize, size_t outputByteSize, int C) {
    using namespace AscendC;

    //int32_t BUFFER_NUM = C / BLOCK_NUM;
    int32_t TOTAL_LENGTH_X = inputByteSize / sizeof(float); //1xCx66x1028
    int32_t TOTAL_LENGTH_Y = outputByteSize / sizeof(float) / 16; //1xCx62x1024
    int32_t BLOCK_LENGTH_X = TOTAL_LENGTH_X / BLOCK_NUM;
    int32_t BLOCK_LENGTH_Y = TOTAL_LENGTH_Y / BLOCK_NUM;

    TPipe pipe;
    TQue<QuePosition::VECIN, BUFFER_NUM> inQueueX, inQueueY;
    TQue<QuePosition::VECOUT, BUFFER_NUM> outQueue;
    GlobalTensor<float> xGm, yGm, outGm;


    xGm.SetGlobalBuffer((__gm__ float*)x + BLOCK_LENGTH_X * GetBlockIdx(), BLOCK_LENGTH_X);
    yGm.SetGlobalBuffer((__gm__ float*)y + BLOCK_LENGTH_Y * GetBlockIdx(), BLOCK_LENGTH_Y);
    outGm.SetGlobalBuffer((__gm__ float*)output + BLOCK_LENGTH_Y * 16 * GetBlockIdx(), BLOCK_LENGTH_Y * 16);

    pipe.InitBuffer(inQueueX, BUFFER_NUM, TILE_LENGTH_X * sizeof(float));
    pipe.InitBuffer(inQueueY, BUFFER_NUM, TILE_LENGTH_Y * sizeof(float));
    pipe.InitBuffer(outQueue, BUFFER_NUM, TILE_LENGTH_Y * 16 * sizeof(float));


    uint32_t loopCount = TILE_NUM * BUFFER_NUM;
    for (uint32_t i = 0; i < loopCount; ++i) {
        // copy in
        LocalTensor<float> xLocal = inQueueX.AllocTensor<float>();
        LocalTensor<float> yLocal = inQueueY.AllocTensor<float>();
        int bufferIdx = i / TILE_NUM;
        DataCopy(xLocal, xGm[bufferIdx * 66 * 1028 + (i - bufferIdx * TILE_NUM) * 1028], TILE_LENGTH_X);
        DataCopy(yLocal, yGm[bufferIdx * 62 * 1024 + (i - bufferIdx * TILE_NUM) * 1024], TILE_LENGTH_Y);
        inQueueX.EnQue(xLocal);
        inQueueY.EnQue(yLocal);

        // compute        
        xLocal = inQueueX.DeQue<float>(); // 5 * 1028
        yLocal = inQueueY.DeQue<float>(); // 1 * 1024
        LocalTensor<float> outLocal = outQueue.AllocTensor<float>(); // 1 * 1024 * 16
        for (uint32_t j = 0; j < TILE_LENGTH_Y; ++j){
            for (uint32_t w = 0; w < 5; ++w){
                int id_top = j + w;
                int id_bottom = j + w + 4 * 1028;
                outLocal[j * 16 + w] = xLocal[id_top] - yLocal[j];
                outLocal[j * 16 + 8 + w] = xLocal[id_bottom] - yLocal[j];
            }
            for (uint32_t h = 1; h <= 3; ++h){
                int id_left = h * 1028 + j;
                int id_right = h * 1028 + j + 4;
                outLocal[j * 16 + 12 + h] = xLocal[id_left] - yLocal[j];
                outLocal[j * 16 + 4 + h] = xLocal[id_right] - yLocal[j];
            }
        }
        outQueue.EnQue<float>(outLocal);
        inQueueX.FreeTensor(xLocal);
        inQueueY.FreeTensor(yLocal);

        // copy out
        outLocal = outQueue.DeQue<float>();
        DataCopy(outGm[bufferIdx * 62 * 1024 * 16 + (i - bufferIdx * TILE_NUM) * 1024 * 16], outLocal, TILE_LENGTH_Y * 16);
        outQueue.FreeTensor(outLocal);
    }
}

int plugin_sub_kernel(float* input, float* output, PluginMetaData plugin_meta_data){
    size_t inputByteSize = plugin_meta_data.input_size * sizeof(float);
    size_t outputByteSize = plugin_meta_data.output_size * sizeof(float);

    // AscendCL初始化
    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    int height = plugin_meta_data.output_shape[2]; //62
    int width = plugin_meta_data.output_shape[3]; //1024
    int C = plugin_meta_data.input_shape[1]; //32 or 64

    //分配Host内存
    //float *input1Host, *input2Host, *outputHost;
    float *input2Host;
    int input2Size = C * height * width;
    size_t input2ByteSize = input2Size * sizeof(float);
    //aclrtMallocHost((void**)&input1Host, inputByteSize);
    aclrtMallocHost((void**)&input2Host, input2ByteSize);
    //aclrtMallocHost((void**)&outputHost, outputByteSize);


    //分配Device内存
    float *input1Device, *input2Device, *outputDevice;
    aclrtMalloc((void **)&input1Device, inputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&input2Device, input2ByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&outputDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);

    // Host内存初始化
    //初始化input1
    //aclrtMemcpy(input1Host, inputByteSize, input, inputByteSize, ACL_MEMCPY_HOST_TO_HOST);
    //初始化input2
    for (int j = 0; j < height; ++j){
        aclrtMemcpy(input2Host + j * width, width * sizeof(float), input + (2 + j) * (width + 4) + 2, width * sizeof(float), ACL_MEMCPY_HOST_TO_HOST);
    }

    //Device内存初始化
    //aclrtMemcpy(input1Device, inputByteSize, input1Host, inputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(input1Device, inputByteSize, input, inputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(input2Device, input2ByteSize, input2Host, input2ByteSize, ACL_MEMCPY_HOST_TO_DEVICE);

    // 调用Kernel
    PluginSub<<<BLOCK_NUM, nullptr, stream>>>(input1Device, input2Device, outputDevice, inputByteSize, outputByteSize, C);
    aclrtSynchronizeStream(stream);

    // Device内存拷贝到Host
    aclrtMemcpy(output, outputByteSize, outputDevice, outputByteSize,
                ACL_MEMCPY_DEVICE_TO_HOST);
    
    //aclrtMemcpy(output, outputByteSize, outputHost, outputByteSize,
    //            ACL_MEMCPY_HOST_TO_HOST);
                
    // 释放资源
    aclrtFree(input1Device);
    aclrtFree(input2Device);
    aclrtFree(outputDevice);
    //aclrtFreeHost(input1Host);
    aclrtFreeHost(input2Host);
    //aclrtFreeHost(outputHost);
    // AscendCL去初始化
    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();
    return 0;
}